# FluxIO Architecture Documentation

## System Overview

FluxIO is a three-tier architecture for industrial IoT data collection and monitoring:

1. **Edge Layer** - Nivus flow transmitters + Teltonika gateway
2. **Application Layer** - Next.js application with API routes
3. **Data Layer** - Supabase (PostgreSQL + Realtime)

## Component Architecture

### 1. Edge Layer (Field Devices)

#### Nivus Flow Transmitters
- **Protocol:** Modbus RTU over RS485
- **Data Format:** Float32 values in holding registers
- **Typical Registers:**
  - Flow Rate: Register 0-1 (2 words)
  - Totalizer: Register 2-3 (2 words)
  - Temperature: Register 4-5 (2 words)
  - Status: Register 10

#### Teltonika TRB245 Gateway
- **Role:** Modbus Master + HTTP Client
- **Function:**
  1. Polls Nivus devices every N seconds
  2. Reads Modbus registers
  3. Converts binary data to JSON
  4. POSTs to FluxIO API via 4G/LTE

**Configuration Flow:**
```
Teltonika → Modbus Request → Nivus Device
Nivus → Modbus Response → Teltonika
Teltonika → JSON over HTTPS → FluxIO API
```

### 2. Application Layer (Next.js)

#### API Routes

**POST /api/ingest**
- **Purpose:** Receive data from gateways
- **Authentication:** API key via header
- **Processing:**
  1. Validate API key
  2. Parse and validate JSON payload
  3. Insert into `flow_data` table
  4. Trigger `update_device_last_seen` function
  5. Check alert conditions
  6. Return success/error response

**GET /api/devices**
- **Purpose:** List all devices with latest data
- **Response:** Devices joined with latest flow data
- **Caching:** Client-side with real-time updates

**GET /api/flow-data**
- **Purpose:** Time-series data retrieval
- **Parameters:**
  - `device_id`: Filter by device
  - `start_time`: ISO 8601 timestamp
  - `end_time`: ISO 8601 timestamp
  - `limit`: Max records (default 1000)
- **Optimization:** Indexed on `(device_id, created_at)`

**GET /api/alerts**
- **Purpose:** Alert management
- **Parameters:**
  - `device_id`: Filter by device
  - `is_resolved`: Boolean filter
  - `limit`: Max records

**PATCH /api/alerts**
- **Purpose:** Mark alerts as resolved
- **Payload:** `{ alert_id, is_resolved, resolved_by }`

#### Dashboard (React Client)

**Components:**
- `StatsCard` - KPI display
- `Card` - Generic container
- `DeviceList` - Real-time device status
- `AlertList` - Active alerts

**State Management:**
- Local React state (useState)
- Real-time via Supabase Realtime subscriptions
- No global state needed (simple app)

**Real-time Updates:**
```javascript
supabase
  .channel('flow_data_changes')
  .on('postgres_changes', { event: 'INSERT', table: 'flow_data' }, () => {
    // Refresh dashboard
  })
  .subscribe()
```

### 3. Data Layer (Supabase)

#### Database Schema

**devices**
- Primary entity for flow transmitters
- Tracks online/offline status via `last_seen`
- Stores metadata in JSONB column
- Indexed on: `device_id`, `status`

**flow_data**
- Time-series table (append-only)
- Partitioning recommended for scale
- Indexed on: `(device_id, created_at DESC)`
- Retention policy: TBD (recommend 90 days hot, archive older)

**alerts**
- Generated by alert engine
- Linked to alert_rules
- Tracks resolution lifecycle
- Indexed on: `(device_id, is_resolved)`

**alert_rules**
- Configuration table
- Supports multiple rule types per device
- JSONB for notification_channels (extensible)

#### Triggers

**update_device_last_seen**
```sql
CREATE TRIGGER update_device_last_seen_trigger
  AFTER INSERT ON flow_data
  FOR EACH ROW
  EXECUTE FUNCTION update_device_last_seen();
```
- Automatically updates `devices.last_seen`
- Enables online/offline detection

#### Views

**dashboard_summary**
```sql
CREATE VIEW dashboard_summary AS
SELECT
  COUNT(DISTINCT d.device_id) AS total_devices,
  COUNT(*) FILTER (WHERE d.last_seen > NOW() - INTERVAL '15 minutes') AS online_devices,
  COUNT(*) FILTER (WHERE a.is_resolved = FALSE) AS active_alerts
FROM devices d
LEFT JOIN alerts a ON d.device_id = a.device_id;
```
- Pre-aggregated stats
- Refreshes on each query (simple view, not materialized)

#### Functions

**get_latest_flow_data()**
- Returns most recent reading per device
- Uses `DISTINCT ON (device_id)`
- Fast due to index on `(device_id, created_at DESC)`

**get_flow_statistics(device_id, start_time, end_time)**
- Calculates: avg, min, max, total_volume
- Used for historical analysis
- Can be extended with hourly/daily aggregates

#### Row Level Security (RLS)

Current state: Permissive (all authenticated users)

**Production recommendations:**
```sql
-- Read-only for viewer role
CREATE POLICY "Viewers can read" ON flow_data
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM users
      WHERE users.id = auth.uid()
      AND users.role IN ('viewer', 'operator', 'admin')
    )
  );

-- Write access for operators and admins
CREATE POLICY "Operators can write" ON flow_data
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM users
      WHERE users.id = auth.uid()
      AND users.role IN ('operator', 'admin')
    )
  );
```

## Data Flow

### Ingest Path (Hot Path)

```
┌────────────────────────────────────────────────────────┐
│ 1. Gateway sends POST to /api/ingest                   │
│    Header: x-api-key: SECRET                           │
│    Body: { device_id, flow_rate, ... }                 │
└────────────────┬───────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────┐
│ 2. API Route validates:                                │
│    - API key matches env var                           │
│    - JSON schema is valid                              │
│    - device_id and at least one measurement present    │
└────────────────┬───────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────┐
│ 3. Insert into flow_data table                         │
│    - Supabase Admin client (bypasses RLS)              │
│    - Returns immediately                               │
└────────────────┬───────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────┐
│ 4. Database trigger fires:                             │
│    - update_device_last_seen()                         │
│    - Sets devices.last_seen = NOW()                    │
└────────────────┬───────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────┐
│ 5. Alert engine checks rules:                          │
│    - Query alert_rules for device                      │
│    - Evaluate thresholds                               │
│    - Insert into alerts if triggered                   │
└────────────────┬───────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────┐
│ 6. Real-time broadcast:                                │
│    - Supabase Realtime notifies subscribed clients     │
│    - Dashboard auto-updates                            │
└────────────────────────────────────────────────────────┘
```

**Performance:** <100ms end-to-end for single reading

### Query Path (Cold Path)

```
┌────────────────────────────────────────────────────────┐
│ 1. User loads dashboard                                │
└────────────────┬───────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────┐
│ 2. Client fetches:                                     │
│    - GET /api/devices (with latest data)               │
│    - GET /api/alerts (unresolved only)                 │
│    - dashboard_summary view                            │
└────────────────┬───────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────┐
│ 3. Subscribe to real-time channels:                    │
│    - flow_data_changes                                 │
│    - alerts_changes                                    │
└────────────────┬───────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────┐
│ 4. Render with React components                       │
└────────────────────────────────────────────────────────┘
```

## Scaling Considerations

### Current Capacity

- **Devices:** Up to 100 with default config
- **Data points:** 100 devices × 60 readings/hour = 6,000/hour
- **Storage:** ~500 bytes/reading = 3MB/hour = ~2GB/month
- **Database:** Supabase Free tier sufficient for testing

### Scale-up Strategy (1,000 devices)

#### 1. Database Optimization

**Partitioning:**
```sql
-- Partition flow_data by month
CREATE TABLE flow_data_202401 PARTITION OF flow_data
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
```

**Indexing:**
```sql
-- Composite index for common queries
CREATE INDEX idx_flow_data_device_time_rate
ON flow_data (device_id, created_at DESC, flow_rate);

-- Partial index for online devices
CREATE INDEX idx_devices_online
ON devices (last_seen)
WHERE last_seen > NOW() - INTERVAL '1 hour';
```

**Materialized Views:**
```sql
-- Pre-aggregate hourly stats
CREATE MATERIALIZED VIEW flow_data_hourly AS
SELECT
  device_id,
  date_trunc('hour', created_at) AS hour,
  AVG(flow_rate) AS avg_flow_rate,
  MAX(flow_rate) AS max_flow_rate,
  MIN(flow_rate) AS min_flow_rate,
  MAX(totalizer) - MIN(totalizer) AS total_volume
FROM flow_data
GROUP BY device_id, date_trunc('hour', created_at);

-- Refresh every hour
CREATE INDEX ON flow_data_hourly (device_id, hour);
```

#### 2. API Layer Optimization

**Rate Limiting:**
```typescript
// middleware.ts
import rateLimit from '@/lib/rate-limit'

export async function middleware(request: NextRequest) {
  const limiter = rateLimit({
    interval: 60 * 1000, // 1 minute
    uniqueTokenPerInterval: 500,
  })

  try {
    await limiter.check(10, 'INGEST_RATE_LIMIT') // 10 requests per minute
  } catch {
    return new Response('Too Many Requests', { status: 429 })
  }
}
```

**Batching:**
- Already supported: Array of readings in single POST
- Gateway should batch 5-10 readings

**Caching:**
```typescript
// Cache device list for 30 seconds
const devicesCacheKey = 'devices:list'
const cached = await redis.get(devicesCacheKey)
if (cached) return JSON.parse(cached)

const devices = await fetchDevicesFromDB()
await redis.set(devicesCacheKey, JSON.stringify(devices), 'EX', 30)
```

#### 3. Infrastructure

**Supabase Pro:**
- Scales to millions of rows
- Point-in-time recovery
- Automated backups

**Vercel Pro:**
- Higher bandwidth limits
- Edge functions for global latency reduction

**CDN:**
- CloudFlare in front of API
- DDoS protection
- SSL termination

#### 4. Monitoring

**Observability Stack:**
- Sentry for error tracking
- Datadog/New Relic for APM
- Supabase built-in metrics

**Alerting:**
- High API latency (>500ms)
- Database connection pool exhaustion
- Disk usage >80%
- Failed ingest rate >1%

## Security Model

### Authentication

**Gateway to API:**
- Bearer token in `x-api-key` header
- Rotated monthly
- One key per gateway (for granular revocation)

**User to Dashboard:**
- Supabase Auth (email/password)
- JWT tokens with 1-hour expiry
- Refresh token rotation

### Authorization

**Role-based access:**
- **admin:** Full access
- **operator:** Read/write data, manage alerts
- **viewer:** Read-only

### Network Security

**Production setup:**
- API behind CloudFlare
- Firewall rules: Allow only known gateway IPs
- HTTPS only (TLS 1.3)
- CORS restricted to dashboard domain

### Data Security

**At rest:**
- Supabase encrypts database at rest (AES-256)
- Backups encrypted

**In transit:**
- HTTPS for all API calls
- WSS for real-time subscriptions

## Failure Modes & Recovery

### Gateway Offline

**Detection:** `devices.last_seen > 15 minutes`

**Response:**
1. Generate `device_offline` alert
2. Send notification (email/SMS)
3. Dashboard shows red status

**Recovery:** Automatic when data resumes

### Database Outage

**Detection:** Connection errors, health check fails

**Response:**
1. Gateway retries with exponential backoff
2. Local buffering on gateway (if supported)
3. Status page shows outage

**Recovery:**
- Supabase SLA: 99.9% uptime
- Automatic failover to replica

### API Overload

**Detection:** Response time >1s, error rate >5%

**Response:**
1. Rate limiting kicks in
2. Auto-scaling (Vercel serverless)
3. Alerts to ops team

**Recovery:** Scales back down when load decreases

## Maintenance

### Daily Tasks
- None (fully automated)

### Weekly Tasks
- Review alert accuracy
- Check for offline devices
- Monitor database size

### Monthly Tasks
- Rotate API keys
- Review and archive old alerts
- Analyze flow trends

### Quarterly Tasks
- Database vacuum (automatic on Supabase)
- Review and optimize slow queries
- Update dependencies

---

**Version:** 1.0.0
**Last Updated:** January 9, 2025
