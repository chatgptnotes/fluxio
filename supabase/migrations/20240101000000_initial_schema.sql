-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create devices table
CREATE TABLE IF NOT EXISTS devices (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  device_id TEXT UNIQUE NOT NULL,
  device_name TEXT NOT NULL,
  device_type TEXT DEFAULT 'nivus_flow_transmitter',
  location TEXT,
  description TEXT,
  status TEXT CHECK (status IN ('active', 'inactive', 'maintenance', 'error')) DEFAULT 'active',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  last_seen TIMESTAMPTZ,
  metadata JSONB DEFAULT '{}'::jsonb
);

-- Create flow_data table
CREATE TABLE IF NOT EXISTS flow_data (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  device_id TEXT NOT NULL,
  flow_rate FLOAT4,
  totalizer FLOAT8,
  temperature FLOAT4,
  pressure FLOAT4,
  battery_level FLOAT4,
  signal_strength INTEGER,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  metadata JSONB DEFAULT '{}'::jsonb,
  CONSTRAINT fk_device FOREIGN KEY (device_id) REFERENCES devices(device_id) ON DELETE CASCADE
);

-- Create alerts table
CREATE TABLE IF NOT EXISTS alerts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  device_id TEXT NOT NULL,
  alert_type TEXT NOT NULL CHECK (alert_type IN ('high_flow', 'low_flow', 'no_data', 'device_offline', 'battery_low', 'zero_flow', 'custom')),
  severity TEXT CHECK (severity IN ('info', 'warning', 'critical')) DEFAULT 'warning',
  message TEXT NOT NULL,
  threshold_value FLOAT4,
  actual_value FLOAT4,
  is_resolved BOOLEAN DEFAULT FALSE,
  resolved_at TIMESTAMPTZ,
  resolved_by TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  metadata JSONB DEFAULT '{}'::jsonb,
  CONSTRAINT fk_device_alert FOREIGN KEY (device_id) REFERENCES devices(device_id) ON DELETE CASCADE
);

-- Create alert_rules table
CREATE TABLE IF NOT EXISTS alert_rules (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  device_id TEXT NOT NULL,
  rule_name TEXT NOT NULL,
  rule_type TEXT NOT NULL CHECK (rule_type IN ('high_flow', 'low_flow', 'no_data', 'device_offline', 'battery_low', 'zero_flow')),
  threshold_value FLOAT4,
  duration_minutes INTEGER DEFAULT 5,
  severity TEXT CHECK (severity IN ('info', 'warning', 'critical')) DEFAULT 'warning',
  is_enabled BOOLEAN DEFAULT TRUE,
  notification_channels JSONB DEFAULT '["email"]'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT fk_device_rule FOREIGN KEY (device_id) REFERENCES devices(device_id) ON DELETE CASCADE
);

-- Create users table (for admin access)
CREATE TABLE IF NOT EXISTS users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  email TEXT UNIQUE NOT NULL,
  full_name TEXT,
  role TEXT CHECK (role IN ('admin', 'operator', 'viewer')) DEFAULT 'viewer',
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create audit_logs table
CREATE TABLE IF NOT EXISTS audit_logs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID,
  action TEXT NOT NULL,
  resource_type TEXT,
  resource_id TEXT,
  details JSONB DEFAULT '{}'::jsonb,
  ip_address TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT fk_user_audit FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
);

-- Create indexes for better query performance
CREATE INDEX idx_flow_data_device_id ON flow_data(device_id);
CREATE INDEX idx_flow_data_created_at ON flow_data(created_at DESC);
CREATE INDEX idx_flow_data_device_time ON flow_data(device_id, created_at DESC);
CREATE INDEX idx_alerts_device_id ON alerts(device_id);
CREATE INDEX idx_alerts_created_at ON alerts(created_at DESC);
CREATE INDEX idx_alerts_unresolved ON alerts(is_resolved) WHERE is_resolved = FALSE;
CREATE INDEX idx_devices_status ON devices(status);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at DESC);

-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create triggers for updated_at
CREATE TRIGGER update_devices_updated_at
  BEFORE UPDATE ON devices
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_alert_rules_updated_at
  BEFORE UPDATE ON alert_rules
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_users_updated_at
  BEFORE UPDATE ON users
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Create function to update device last_seen
CREATE OR REPLACE FUNCTION update_device_last_seen()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE devices
  SET last_seen = NEW.created_at
  WHERE device_id = NEW.device_id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for updating device last_seen on new flow data
CREATE TRIGGER update_device_last_seen_trigger
  AFTER INSERT ON flow_data
  FOR EACH ROW
  EXECUTE FUNCTION update_device_last_seen();

-- Create function to get latest flow data for each device
CREATE OR REPLACE FUNCTION get_latest_flow_data()
RETURNS TABLE (
  device_id TEXT,
  flow_rate FLOAT4,
  totalizer FLOAT8,
  temperature FLOAT4,
  pressure FLOAT4,
  created_at TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  SELECT DISTINCT ON (fd.device_id)
    fd.device_id,
    fd.flow_rate,
    fd.totalizer,
    fd.temperature,
    fd.pressure,
    fd.created_at
  FROM flow_data fd
  ORDER BY fd.device_id, fd.created_at DESC;
END;
$$ LANGUAGE plpgsql;

-- Create function to get flow statistics
CREATE OR REPLACE FUNCTION get_flow_statistics(
  p_device_id TEXT,
  p_start_time TIMESTAMPTZ,
  p_end_time TIMESTAMPTZ
)
RETURNS TABLE (
  avg_flow_rate FLOAT4,
  min_flow_rate FLOAT4,
  max_flow_rate FLOAT4,
  total_volume FLOAT8,
  data_points BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    AVG(fd.flow_rate)::FLOAT4 AS avg_flow_rate,
    MIN(fd.flow_rate)::FLOAT4 AS min_flow_rate,
    MAX(fd.flow_rate)::FLOAT4 AS max_flow_rate,
    MAX(fd.totalizer) - MIN(fd.totalizer) AS total_volume,
    COUNT(*)::BIGINT AS data_points
  FROM flow_data fd
  WHERE fd.device_id = p_device_id
    AND fd.created_at >= p_start_time
    AND fd.created_at <= p_end_time;
END;
$$ LANGUAGE plpgsql;

-- Enable Row Level Security (RLS)
ALTER TABLE devices ENABLE ROW LEVEL SECURITY;
ALTER TABLE flow_data ENABLE ROW LEVEL SECURITY;
ALTER TABLE alerts ENABLE ROW LEVEL SECURITY;
ALTER TABLE alert_rules ENABLE ROW LEVEL SECURITY;
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

-- Create RLS policies (allow all for authenticated users for now)
-- In production, these should be more restrictive based on user roles

CREATE POLICY "Allow all for authenticated users" ON devices
  FOR ALL USING (auth.role() = 'authenticated');

CREATE POLICY "Allow all for authenticated users" ON flow_data
  FOR ALL USING (auth.role() = 'authenticated');

CREATE POLICY "Allow all for authenticated users" ON alerts
  FOR ALL USING (auth.role() = 'authenticated');

CREATE POLICY "Allow all for authenticated users" ON alert_rules
  FOR ALL USING (auth.role() = 'authenticated');

CREATE POLICY "Allow all for authenticated users" ON users
  FOR ALL USING (auth.role() = 'authenticated');

CREATE POLICY "Allow all for authenticated users" ON audit_logs
  FOR ALL USING (auth.role() = 'authenticated');

-- Insert default admin user (update with your email)
INSERT INTO users (email, full_name, role)
VALUES ('admin@flownexus.work', 'Admin User', 'admin')
ON CONFLICT (email) DO NOTHING;

-- Insert sample devices for testing
INSERT INTO devices (device_id, device_name, location, description) VALUES
  ('NIVUS_01', 'Main Inlet Flow', 'Plant A - Inlet', 'Primary inlet flow measurement'),
  ('NIVUS_02', 'Secondary Inlet', 'Plant A - Secondary', 'Secondary inlet flow measurement'),
  ('NIVUS_03', 'Outlet Flow', 'Plant A - Outlet', 'Outlet flow measurement'),
  ('NIVUS_04', 'Backup Flow', 'Plant B - Backup', 'Backup flow sensor')
ON CONFLICT (device_id) DO NOTHING;

-- Insert sample alert rules
INSERT INTO alert_rules (device_id, rule_name, rule_type, threshold_value, severity) VALUES
  ('NIVUS_01', 'High Flow Alert', 'high_flow', 100.0, 'warning'),
  ('NIVUS_01', 'Low Flow Alert', 'low_flow', 5.0, 'warning'),
  ('NIVUS_01', 'Device Offline', 'device_offline', NULL, 'critical'),
  ('NIVUS_02', 'High Flow Alert', 'high_flow', 80.0, 'warning'),
  ('NIVUS_03', 'Device Offline', 'device_offline', NULL, 'critical')
ON CONFLICT DO NOTHING;

-- Create a view for dashboard summary
CREATE OR REPLACE VIEW dashboard_summary AS
SELECT
  COUNT(DISTINCT d.device_id) AS total_devices,
  COUNT(DISTINCT d.device_id) FILTER (WHERE d.status = 'active') AS active_devices,
  COUNT(DISTINCT d.device_id) FILTER (WHERE d.last_seen > NOW() - INTERVAL '15 minutes') AS online_devices,
  COUNT(*) FILTER (WHERE a.is_resolved = FALSE) AS active_alerts,
  COUNT(*) FILTER (WHERE a.severity = 'critical' AND a.is_resolved = FALSE) AS critical_alerts
FROM devices d
LEFT JOIN alerts a ON d.device_id = a.device_id;

COMMENT ON TABLE devices IS 'Stores information about flow transmitter devices';
COMMENT ON TABLE flow_data IS 'Stores time-series flow measurement data from devices';
COMMENT ON TABLE alerts IS 'Stores alerts generated by the system';
COMMENT ON TABLE alert_rules IS 'Stores alert rules configuration for devices';
COMMENT ON TABLE users IS 'Stores user information and access control';
COMMENT ON TABLE audit_logs IS 'Stores audit trail of user actions';
